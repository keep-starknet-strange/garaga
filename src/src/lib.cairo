pub mod apps {
    pub mod drand;
    pub mod noir;
    pub mod risc0;
    pub mod sp1;
    pub mod sp1_constants;
}

pub mod basic_field_ops;
pub mod core {
    pub mod circuit;
}
pub mod circuits {
    pub(crate) mod dummy;
    pub(crate) mod ec;
    pub(crate) mod extf_mul;
    pub(crate) mod isogeny;
    pub(crate) mod multi_pairing_check;
    pub(crate) mod tower_circuits;
}
pub mod crypto {
    pub mod mmr;
}

pub mod definitions;

pub mod ec {
    pub mod ec_ops;
    pub mod ec_ops_g2;
    pub mod selectors;
    pub mod pairing {
        pub mod groth16;
        pub mod pairing_check;
        pub mod single_pairing_tower;
    }
}

pub mod hashes {
    pub mod poseidon_bn254;
    pub mod sha_512;
    pub use poseidon_bn254::poseidon_hash_2_bn254;
    pub use sha_512::sha512;
}

pub mod signatures {
    pub mod ecdsa;
    pub mod eddsa_25519;
    pub mod schnorr;
}

mod tests {
    mod autogenerated {
        #[cfg(test)]
        mod ecdsa_tests;
        #[cfg(test)]
        mod eddsa_tests;
        #[cfg(test)]
        mod msm_tests;
        #[cfg(test)]
        mod pairing_tests;
        #[cfg(test)]
        mod schnorr_tests;
        #[cfg(test)]
        mod tower_pairing_tests;
    }
    #[cfg(test)]
    mod calldata_tests;
    #[cfg(test)]
    mod sha512_tests;
    #[cfg(test)]
    mod sp1_groth_16_tests;
}

pub mod utils {
    pub mod calldata;
    pub mod hashing;
    pub mod neg_3;
    use core::circuit::u384;
    use core::panic_with_felt252;

    pub fn u384_assert_zero(x: u384) {
        if x.limb0 != 0 {
            panic_with_felt252('not zero l0');
        }
        if x.limb1 != 0 {
            panic_with_felt252('not zero l1');
        }
        if x.limb2 != 0 {
            panic_with_felt252('not zero l2');
        }
        if x.limb3 != 0 {
            panic_with_felt252('not zero l3');
        }
    }

    pub fn u384_assert_eq(x: u384, y: u384) {
        if x.limb0 != y.limb0 {
            panic_with_felt252('not equal l0');
        }
        if x.limb1 != y.limb1 {
            panic_with_felt252('not equal l1');
        }
        if x.limb2 != y.limb2 {
            panic_with_felt252('not equal l2');
        }
        if x.limb3 != y.limb3 {
            panic_with_felt252('not equal l3');
        }
    }
    pub fn usize_assert_eq(x: usize, y: usize) {
        if x != y {
            panic_with_felt252('not equal usize');
        }
    }


    // Returns true if all limbs of x are zero, false otherwise.
    pub fn u384_eq_zero(x: u384) -> bool {
        if x.limb0 != 0 {
            return false;
        }
        if x.limb1 != 0 {
            return false;
        }
        if x.limb2 != 0 {
            return false;
        }
        if x.limb3 != 0 {
            return false;
        }
        true
    }
}


pub use garaga::ec::ec_ops;
pub use garaga::ec::ec_ops_g2;
pub use garaga::ec::pairing::{groth16, pairing_check, single_pairing_tower};


#[cfg(test)]
mod tests_lib {
    use core::circuit::{
        AddInputResultTrait, AddMod, CircuitElement, CircuitInput, CircuitInputs, CircuitModulus,
        CircuitOutputsTrait, EvalCircuitTrait, MulMod, RangeCheck96, circuit_add, circuit_inverse,
        circuit_mul, circuit_sub, u384, u96,
    };
    use core::traits::TryInto;
    #[test]
    #[ignore] // Ignored for auto-benchmarks
    fn test_u96() {
        let a: u96 = 0x123;
        assert_eq!(a, 0x123);
    }
    #[test]
    #[ignore] // Ignored for auto-benchmarks
    fn test_builtins() {
        core::internal::require_implicit::<RangeCheck96>();
        core::internal::require_implicit::<AddMod>();
        core::internal::require_implicit::<MulMod>();
    }
    #[test]
    #[ignore] // Ignored for auto-benchmarks
    fn test_circuit_success() {
        let in1 = CircuitElement::<CircuitInput<0>> {};
        let in2 = CircuitElement::<CircuitInput<1>> {};
        let add = circuit_add(in1, in2);
        let inv = circuit_inverse(add);
        let sub = circuit_sub(inv, in2);
        let mul = circuit_mul(inv, sub);

        let modulus = TryInto::<_, CircuitModulus>::try_into([7, 0, 0, 0]).unwrap();
        let outputs = (mul, add, inv)
            .new_inputs()
            .next([3, 0, 0, 0])
            .next([6, 0, 0, 0])
            .done()
            .eval(modulus)
            .unwrap();

        assert_eq!(outputs.get_output(add), u384 { limb0: 2, limb1: 0, limb2: 0, limb3: 0 });
        assert_eq!(outputs.get_output(inv), u384 { limb0: 4, limb1: 0, limb2: 0, limb3: 0 });
        assert_eq!(outputs.get_output(sub), u384 { limb0: 5, limb1: 0, limb2: 0, limb3: 0 });
        assert_eq!(outputs.get_output(mul), u384 { limb0: 6, limb1: 0, limb2: 0, limb3: 0 });
    }

    #[test]
    #[ignore] // Ignored for auto-benchmarks
    fn test_circuit_failure() {
        let in0 = CircuitElement::<CircuitInput<0>> {};
        let out0 = circuit_inverse(in0);

        let modulus = TryInto::<_, CircuitModulus>::try_into([55, 0, 0, 0]).unwrap();
        (out0,).new_inputs().next([11, 0, 0, 0]).done().eval(modulus).unwrap_err();
    }
    #[test]
    #[ignore] // Ignored for auto-benchmarks
    fn test_fill_inputs_loop() {
        let in1 = CircuitElement::<CircuitInput<0>> {};
        let in2 = CircuitElement::<CircuitInput<1>> {};
        let add = circuit_add(in1, in2);

        let mut inputs: Array<[u96; 4]> = array![[1, 0, 0, 0], [2, 0, 0, 0]];
        let mut circuit_inputs = (add,).new_inputs();

        while let Option::Some(input) = inputs.pop_front() {
            circuit_inputs = circuit_inputs.next(input);
        }

        let modulus = TryInto::<_, CircuitModulus>::try_into([55, 0, 0, 0]).unwrap();
        circuit_inputs.done().eval(modulus).unwrap();
    }
}
