//! # Starknet Verification Contract Tests
//!
//! This module contains comprehensive tests for the proof verification contract.
//! The tests use Starknet Foundry's testing features to verify proofs.
//!
//! ## Test Strategy
//! - Use real proof fixtures generated by the garaga CLI
//! - Test both positive (valid proof) and negative (invalid proof) cases

use groth16_example_bls12_381::groth16_verifier::{
    IGroth16VerifierBLS12_381DispatcherTrait, IGroth16VerifierBLS12_381LibraryDispatcher,
};
use snforge_std::fs::{FileTrait, read_txt};
use snforge_std::{DeclareResultTrait, declare};
use starknet::ClassHash;

/// Declare the Groth16VerifierBLS12_381 contract for testing.
///
/// This function declares a new instance of the Groth16VerifierBLS12_381 contract
///
/// # Arguments
/// * `name` - The contract name to declare
///
/// # Returns
/// * `ClassHash` - The class hash of the declared contract
///
/// # Example
/// ```cairo
/// let class_hash = declare_contract("Groth16VerifierBLS12_381");
/// let dispatcher = IGroth16VerifierBLS12_381LibraryDispatcher { class_hash };
/// ```
fn declare_contract(name: ByteArray) -> ClassHash {
    let class_hash = *declare(name).unwrap().contract_class().class_hash;
    class_hash
}

/// Test the verification function verify_groth16_proof_bls12_381 with a valid proof.
///
/// This test demonstrates the complete verification flow:
/// 1. Declare the verification contract
/// 2. Load a pre-generated proof fixture
/// 3. Verify the proof on-chain
/// 4. Assert that verification succeeds
///
/// ## Test Setup
/// - Uses fork testing against Sepolia testnet to access required declared contracts maintained by
/// the garaga team - Loads proof calldata from `tests/proof_calldata.txt`
/// - To generate the calldata, you can use the garaga CLI:
/// ```bash
/// garaga calldata
///     --system groth16
///     --vk path/to/vk
///     --proof path/to/proof
///     --public-inputs path/to/public_inputs
///     --format snforge
///     --output-path path/to/tests
/// ```
/// This will generate a file `proof_calldata.txt` in the specified output path.
/// You can then use this file in the test.
///
/// ## Expected Behavior
/// - The proof should verify successfully
/// - The function should return Some(public_inputs) containing the expected public inputs
/// - No panics or assertion failures should occur
#[test]
#[fork(url: "https://starknet-sepolia.public.blastapi.io/rpc/v0_8", block_tag: latest)]
fn test_verify_groth16_proof_bls12_381() {
    // Step 1: Declare the verification contract
    let class_hash = declare_contract("Groth16VerifierBLS12_381");
    let dispatcher = IGroth16VerifierBLS12_381LibraryDispatcher { class_hash };

    // Step 2: Load the proof fixture generated by the script
    // This file contains the Groth16 proof calldata formatted for Starknet
    let file = FileTrait::new("tests/proof_calldata.txt");
    let calldata = read_txt(@file).span();

    // Step 3: Verify the proof on-chain
    // This calls the contract's verify_groth16_proof_bls12_381 function with the loaded proof data
    let result = dispatcher.verify_groth16_proof_bls12_381(calldata);

    // Step 4: Assert that verification succeeded
    // A valid proof should return Some(public_inputs), not None
    assert(result.is_some(), 'Proof is invalid');
    // Optional: You can also verify the public inputs contain expected values
// let public_inputs = result.unwrap();
// assert(public_inputs.len() > 0, 'No public inputs');
// Additional assertions on the public input values can be added here
}
