//! # Starknet Verification Contract Tests
//!
//! This module contains comprehensive tests for the proof verification contract.
//! The tests use Starknet Foundry's testing features to verify proofs.
//!
//! ## Test Strategy
//! - Use real proof fixtures generated by the garaga CLI
//! - Test both positive (valid proof) and negative (invalid proof) cases

use noir_ultra_keccak_zk_honk_example::honk_verifier::{
    IUltraKeccakZKHonkVerifierDispatcher, IUltraKeccakZKHonkVerifierDispatcherTrait,
};
use snforge_std::fs::{FileTrait, read_txt};
use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};
use starknet::ContractAddress;

/// Deploy the UltraKeccakZKHonkVerifier contract for testing.
///
/// This function declares and deploys a new instance of the UltraKeccakZKHonkVerifier contract
/// with default constructor arguments (empty array).
///
/// # Arguments
/// * `name` - The contract name to declare and deploy
///
/// # Returns
/// * `ContractAddress` - The address of the deployed contract
///
/// # Example
/// ```cairo
/// let contract_address = deploy_contract("UltraKeccakZKHonkVerifier");
/// let dispatcher = IUltraKeccakZKHonkVerifierDispatcher { contract_address };
/// ```
fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap().contract_class();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

/// Test the verification function verify_ultra_keccak_zk_honk_proof with a valid proof.
///
/// This test demonstrates the complete verification flow:
/// 1. Deploy the verification contract
/// 2. Load a pre-generated proof fixture
/// 3. Verify the proof on-chain
/// 4. Assert that verification succeeds
///
/// ## Test Setup
/// - Uses fork testing against Sepolia testnet to access required declared contracts maintained by
/// the garaga team - Loads proof calldata from `tests/proof_calldata.txt`
/// - To generate the calldata, you can use the garaga CLI:
/// ```bash
/// garaga calldata ///     --system ultra_keccak_zk_honk ///     --vk path/to/vk ///     --proof
/// path/to/proof ///     --public-inputs path/to/public_inputs ///     --format snforge ///
/// --output-path path/to/tests ```
/// This will generate a file `proof_calldata.txt` in the specified output path.
/// You can then use this file in the test.
///
/// ## Expected Behavior
/// - The proof should verify successfully
/// - The function should return Some(public_inputs) containing the expected public inputs
/// - No panics or assertion failures should occur
#[test]
#[fork(url: "https://starknet-sepolia.public.blastapi.io/rpc/v0_8", block_tag: latest)]
fn test_verify_ultra_keccak_zk_honk_proof() {
    // Step 1: Deploy the verification contract
    let contract_address = deploy_contract("UltraKeccakZKHonkVerifier");
    let dispatcher = IUltraKeccakZKHonkVerifierDispatcher { contract_address };

    // Step 2: Load the proof fixture generated by the script
    // This file contains the Groth16 proof calldata formatted for Starknet
    let file = FileTrait::new("tests/proof_calldata.txt");
    let calldata = read_txt(@file).span();

    // Step 3: Verify the proof on-chain
    // This calls the contract's verify_ultra_keccak_zk_honk_proof function with the loaded proof
    // data
    let result = dispatcher.verify_ultra_keccak_zk_honk_proof(calldata);

    // Step 4: Assert that verification succeeded
    // A valid proof should return Some(public_inputs), not None
    assert(result.is_some(), 'Proof is invalid');
    // Optional: You can also verify the public inputs contain expected values
// let public_inputs = result.unwrap();
// assert(public_inputs.len() > 0, 'No public inputs');
// Additional assertions on the public input values can be added here
}
