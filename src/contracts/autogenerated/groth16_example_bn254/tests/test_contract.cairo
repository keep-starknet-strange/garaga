//! # SP1 Starknet Verification Contract Tests
//!
//! This module contains comprehensive tests for the SP1 proof verification contract.
//! The tests use Starknet Foundry's fork testing feature to verify proofs against
//! the actual Garaga SP1 Verifier deployed on Sepolia testnet.
//!
//! ## Test Strategy
//! - Use real proof fixtures generated by the SP1 proof generation scripts
//! - Fork Sepolia testnet to access the deployed Garaga verifier
//! - Test both positive (valid proof) and negative (invalid proof) cases

use groth16_example_bn254::groth16_verifier::{
    IGroth16VerifierBN254Dispatcher, IGroth16VerifierBN254DispatcherTrait,
};
use snforge_std::fs::{File, FileTrait, read_txt};
use snforge_std::{ContractClassTrait, DeclareResultTrait, declare};
use starknet::ContractAddress;

/// Deploy the Groth16VerifierBN254 contract for testing.
///
/// This function declares and deploys a new instance of the Groth16VerifierBN254 contract
/// with default constructor arguments (empty array).
///
/// # Arguments
/// * `name` - The contract name to declare and deploy
///
/// # Returns
/// * `ContractAddress` - The address of the deployed contract
///
/// # Example
/// ```cairo
/// let contract_address = deploy_contract("Groth16VerifierBN254");
/// let dispatcher = IGroth16VerifierBN254Dispatcher { contract_address };
/// ```
fn deploy_contract(name: ByteArray) -> ContractAddress {
    let contract = declare(name).unwrap().contract_class();
    let (contract_address, _) = contract.deploy(@ArrayTrait::new()).unwrap();
    contract_address
}

/// Test the verification function verify_groth16_proof_bn254 with a valid proof.
///
/// This test demonstrates the complete verification flow:
/// 1. Deploy the verification contract
/// 2. Load a pre-generated proof fixture
/// 3. Verify the proof on-chain
/// 4. Assert that verification succeeds
///
/// ## Test Setup
/// - Uses fork testing against Sepolia testnet to access required declared contracts maintained by
/// the garaga team - Loads proof calldata from `tests/proof_calldata.txt`
/// - To generate the calldata, you can use the garaga CLI:
/// ```bash
/// garaga calldata ///     --system groth16 ///     --vk path/to/vk ///     --proof path/to/proof
/// ///     --public-inputs path/to/public_inputs ///     --format snforge ///     --output-path
/// path/to/tests ```
/// This will generate a file `proof_calldata.txt` in the specified output path.
/// You can then use this file in the test.
///
/// ## Expected Behavior
/// - The proof should verify successfully
/// - The function should return Some(public_inputs) containing the expected public inputs
/// - No panics or assertion failures should occur
#[test]
#[fork(url: "https://starknet-sepolia.public.blastapi.io/rpc/v0_8", block_tag: latest)]
fn test_verify_groth16_proof_bn254() {
    // Step 1: Deploy the verification contract
    let contract_address = deploy_contract("Groth16VerifierBN254");
    let dispatcher = IGroth16VerifierBN254Dispatcher { contract_address };

    // Step 2: Load the proof fixture generated by the script
    // This file contains the Groth16 proof calldata formatted for Starknet
    let file = FileTrait::new("tests/proof_calldata.txt");
    let calldata = read_txt(@file).span();

    // Step 3: Verify the proof on-chain
    // This calls the contract's verify_groth16_proof_bn254 function with the loaded proof data
    let result = dispatcher.verify_groth16_proof_bn254(calldata);

    // Step 4: Assert that verification succeeded
    // A valid proof should return Some(public_inputs), not None
    assert(result.is_some(), 'Proof is invalid');
    // Optional: You can also verify the public inputs contain expected values
// let public_inputs = result.unwrap();
// assert(public_inputs.len() > 0, 'No public inputs');
// Additional assertions on the public input values can be added here
}
