// Generated by Garaga version 1.0.1

use super::groth16_verifier_constants::{N_FREE_PUBLIC_INPUTS, T, ic, precomputed_lines, vk};

#[starknet::interface]
pub trait IRisc0Groth16VerifierBN254<TContractState> {
    fn verify_r0_groth16_proof_bn254(
        self: @TContractState, full_proof_with_hints: Span<felt252>,
    ) -> Result<Span<u8>, felt252>;
}

#[starknet::contract]
mod Risc0Groth16VerifierBN254 {
    use garaga::apps::risc0::{
        compute_receipt_claim, deserialize_full_proof_with_hints_risc0, journal_sha256,
    };
    use garaga::definitions::{G1G2Pair, G1Point};
    use garaga::ec_ops::{G1PointTrait, ec_safe_add};
    use garaga::groth16::{
        Groth16ProofRawTrait, multi_pairing_check_bn254_3P_2F_with_extra_miller_loop_result,
    };
    use starknet::SyscallResultTrait;
    use super::{N_FREE_PUBLIC_INPUTS, T, ic, precomputed_lines, vk};

    const ECIP_OPS_CLASS_HASH: felt252 =
        0x312d1dd5f967eaf6f86965e3fa7acbc9d0fbd979066a17721dd913736af2f5e;

    #[storage]
    struct Storage {}

    #[abi(embed_v0)]
    impl IRisc0Groth16VerifierBN254 of super::IRisc0Groth16VerifierBN254<ContractState> {
        fn verify_r0_groth16_proof_bn254(
            self: @ContractState, full_proof_with_hints: Span<felt252>,
        ) -> Result<Span<u8>, felt252> {
            // DO NOT EDIT THIS FUNCTION UNLESS YOU KNOW WHAT YOU ARE DOING.
            // This function returns Result::Ok(public_inputs) if the proof is valid.
            // If the proof is invalid, it returns Result::Err(error).
            // Read the documentation to learn how to generate the full_proof_with_hints array given
            // a proof and a verifying key.

            let fph = deserialize_full_proof_with_hints_risc0(full_proof_with_hints);

            let groth16_proof = fph.groth16_proof;
            let image_id = fph.image_id;
            let journal = fph.journal;
            let mpcheck_hint = fph.mpcheck_hint;
            let msm_hint = fph.msm_hint;

            groth16_proof.check_proof_points(0);

            let ic = ic.span();

            let journal_digest = journal_sha256(journal);
            let claim_digest = compute_receipt_claim(image_id, journal_digest);

            // Start serialization with the hint array directly to avoid copying it.
            let mut msm_calldata: Array<felt252> = array![];
            // Add the points from VK relative to the non-constant public inputs.
            Serde::serialize(@ic.slice(3, N_FREE_PUBLIC_INPUTS), ref msm_calldata);
            // Add the claim digest as u256 scalars for the msm.
            msm_calldata.append(2);
            msm_calldata.append(claim_digest.low.into());
            msm_calldata.append(0);
            msm_calldata.append(claim_digest.high.into());
            msm_calldata.append(0);
            // Complete with the curve indentifier (0 for BN254):
            msm_calldata.append(0);
            // Add the hint array.
            for x in msm_hint {
                msm_calldata.append(*x);
            }

            // Call the multi scalar multiplication endpoint on the Garaga ECIP ops contract
            // to obtain claim0 * IC[3] + claim1 * IC[4].
            let mut _msm_result_serialized = starknet::syscalls::library_call_syscall(
                ECIP_OPS_CLASS_HASH.try_into().unwrap(), selector!("msm_g1"), msm_calldata.span(),
            )
                .unwrap_syscall();

            // Finalize vk_x computation by adding the precomputed T point.
            let vk_x = ec_safe_add(
                T, Serde::<G1Point>::deserialize(ref _msm_result_serialized).unwrap(), 0,
            );

            // Perform the pairing check.
            let check = multi_pairing_check_bn254_3P_2F_with_extra_miller_loop_result(
                G1G2Pair { p: vk_x, q: vk.gamma_g2 },
                G1G2Pair { p: groth16_proof.c, q: vk.delta_g2 },
                G1G2Pair { p: groth16_proof.a.negate(0), q: groth16_proof.b },
                vk.alpha_beta_miller_loop_result,
                precomputed_lines.span(),
                mpcheck_hint,
            );
            match check {
                Result::Ok(_) => Result::Ok(journal),
                Result::Err(error) => Result::Err(error),
            }
        }
    }
}

