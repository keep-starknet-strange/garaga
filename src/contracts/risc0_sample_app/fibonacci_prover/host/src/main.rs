// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use garaga_rs::calldata::full_proof_with_hints::groth16::risc0_utils::get_risc0_vk;
use garaga_rs::calldata::full_proof_with_hints::groth16::{get_groth16_calldata, Groth16Proof};
use garaga_rs::definitions::CurveID;
use methods::FIBONACCI_GUEST_ELF;
use risc0_ethereum_contracts::encode_seal;
use risc0_zkvm::{compute_image_id, default_prover, ExecutorEnv, ProverOpts, VerifierContext};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // A default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let l: u32 = 3; // public lower bound for n
    let u: u32 = 8; // public upper bound for n
    let n: u32 = 6; // private n for which we will compute fibonacci(n)
    let env = ExecutorEnv::builder()
        .write(&l)
        .unwrap()
        .write(&u)
        .unwrap()
        .write(&n)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove_with_ctx(
            env,
            &VerifierContext::default(),
            FIBONACCI_GUEST_ELF,
            &ProverOpts::groth16(),
        )
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;
    let seal = to_bytes(encode_seal(&receipt).unwrap());
    let image_id = to_bytes(compute_image_id(&FIBONACCI_GUEST_ELF).unwrap());
    let journal = to_bytes(receipt.journal);
    // prints the proof artifact as JSON
    println!(
        "{{\"seal\": \"0x{}\", \"image_id\": \"0x{}\", \"journal\": \"0x{}\"}}",
        hex::encode(&seal),
        hex::encode(&image_id),
        hex::encode(&journal)
    );

    // helper function to convert objects to array of bytes
    fn to_bytes<T: AsRef<[u8]>>(obj: T) -> Vec<u8> {
        obj.as_ref().to_vec()
    }

    // prints the calldata as JSON
    let proof = Groth16Proof::from_risc0(seal, image_id, journal);
    let calldata = get_groth16_calldata(&proof, &get_risc0_vk(), CurveID::BN254).unwrap();
    println!(
        "[{}]",
        calldata
            .iter()
            .skip(1)
            .map(|v| format!("\"{}\"", v))
            .collect::<Vec<_>>()
            .join(", ")
    );
}
