#!/usr/bin/env node

// This script will patch a 'wasm-pack --target web' output folder
// to make the code platform agnostic (browser vs nodejs/commonjs vs esm)

const fs = require('fs');
const path = require('path');
const child_process = require('child_process');

function transpileExports(input) {
  // this is a simple/non-comprehensive implementation
  // can be replaced by a real transpiler (e.g. npx mjs-to-cjs in.mjs out.cjs)
  return input
    // deals with: export function ...
    .replace(/\bexport\s+function\s+(\w+)\s*\(/g, 'exports.$1 = $1;\nfunction $1(')
    // deals with: export { ... }
    .replace(/\bexport\s*\{([\w\s,]*)\}\s*;/g, (match, $1) => {
      const ids = $1.split(',').map((id) => id.trim());
      return ids.map((id) => 'exports.' + id + ' = ' + id + ';').join('\n');
    });
}

function patch() {
  // package name
  const pkgName = 'garaga_rs';

  // package folder
  const pkgFolder = path.join(__dirname, 'pkg');

  // file names
  const jsonName = 'package.json';

  const jsName = pkgName + '.js';
  const tsName = pkgName + '.d.ts';
  const wasmName = pkgName + '_bg.wasm';
  const wasmtsName = pkgName + '_bg.wasm.d.ts';

  const cjsName = pkgName + '.cjs';
  const mjsName = pkgName + '.mjs';
  const wasmcjsName = pkgName + '_bg.wasm.cjs';
  const wasmmjsName = pkgName + '_bg.wasm.mjs';

  // file paths
  const jsonFile = path.join(pkgFolder, jsonName);

  const jsFile = path.join(pkgFolder, jsName);
  const tsFile = path.join(pkgFolder, tsName);
  const wasmFile = path.join(pkgFolder, wasmName);
  const wasmtsFile = path.join(pkgFolder, wasmtsName);

  const cjsFile = path.join(pkgFolder, cjsName);
  const mjsFile = path.join(pkgFolder, mjsName);
  const wasmcjsFile = path.join(pkgFolder, wasmcjsName);
  const wasmmjsFile = path.join(pkgFolder, wasmmjsName);

  // if already patched, skip
  if (fs.existsSync(wasmmjsFile)) return;

  // patches .json file:
  // - sets .cjs as main
  // - sets .mjs as module
  // - sets sideEffects to false
  // - replaces references to .js file by .cjs and .mjs files
  // - replaces references to .wasm file by .wasm.cjs and .wasm.mjs files
  {
    const input = fs.readFileSync(jsonFile, 'utf8');
    const json = JSON.parse(input);
    json['main'] = cjsName;
    json['module'] = mjsName;
    json['sideEffects'] = false;
    json['files'] = json['files'] || [];
    json['files'] = json['files'].filter((name) => ![jsName, wasmName].includes(name));
    json['files'].push(cjsName);
    json['files'].push(mjsName);
    json['files'].push(wasmcjsName);
    json['files'].push(wasmmjsName);
    json['exports'] = json['exports'] || {};
    json['exports']['.'] = json['exports']['.'] || {};
    json['exports']['.']['require'] = './' + json['main'];
    json['exports']['.']['import'] = './' + json['module'];
    json['exports']['.']['types'] = './' + json['types'];
    const output = JSON.stringify(json, undefined, 2);
    fs.writeFileSync(jsonFile, output, 'utf8');
  }

  // patches .d.ts file:
  {
    const exportFunc = 'export function init(): Promise<InitOutput>;';
    const input = fs.readFileSync(tsFile, 'utf8')
      .replace(/\bexport\s+default\s+[^;]+;/, '');
    const output =
      exportFunc + '\n\n' +
      input;
    fs.writeFileSync(tsFile, output, 'utf8');
  }

  // creates .mjs file:
  // - uses .wasm.mjs file as the default WASM module
  {
    const importStmt = 'import default_module_or_path from \'./' + wasmmjsName + '\';';
    const exportFunc = 'export function init() { return __wbg_init({ module_or_path: default_module_or_path }); }';
    const input = fs.readFileSync(jsFile, 'utf8')
      .replace('new URL(\'' + wasmName + '\', import.meta.url)', 'default_module_or_path')
      .replace(/\bexport\s+default\s+[^;]+;/, '');
    const output =
      importStmt + '\n\n' +
      exportFunc + '\n\n' +
      input;
    fs.writeFileSync(mjsFile, output, 'utf8');
  }

  // creates .cjs file:
  // - uses .wasm.cjs file as the default WASM module
  {
    const importStmt = 'const default_module_or_path = require(\'./' + wasmcjsName + '\');';
    const exportFunc = 'exports.init = init;\nfunction init() { return __wbg_init({ module_or_path: default_module_or_path }); }';
    const input = fs.readFileSync(jsFile, 'utf8')
      .replace('new URL(\'' + wasmName + '\', import.meta.url)', 'default_module_or_path')
      .replace(/\bexport\s+default\s+[^;]+;/, '');
    const output =
      '\'use strict\';' + '\n\n' +
      importStmt + '\n\n' +
      exportFunc + '\n\n' +
      transpileExports(input);
    fs.writeFileSync(cjsFile, output, 'utf8');
  }

  // encodes .wasm file as .wasm.cjs:
  // - creates a .wasm.cjs file exporting the binary contents of the .wasm file
  {
    const input = fs.readFileSync(wasmFile).toString('base64');
    const output =
      '\'use strict\';' + '\n\n' +
      'module.exports = "data:application/wasm;base64,' + input + '";';
    fs.writeFileSync(wasmcjsFile, output, 'utf8');
  }

  // encodes .wasm file as .wasm.mjs:
  // - creates a .wasm.mjs file exporting the binary contents of the .wasm file
  {
    const input = fs.readFileSync(wasmFile).toString('base64');
    const output =
      'export default "data:application/wasm;base64,' + input + '";';
    fs.writeFileSync(wasmmjsFile, output, 'utf8');
  }

  // cleans up now obsolete files:
  // - removes .js, .wasm, and .wasm.d.ts files
  {
    fs.rmSync(jsFile);
    fs.rmSync(wasmFile);
    fs.rmSync(wasmtsFile);
  }
}

function build() {
  const command = 'wasm-pack build --target web --release --no-default-features --features wasm';
  child_process.execSync(command, { cwd: __dirname });
}

function clean() {
  const pkgFolder = path.join(__dirname, 'pkg');
  fs.rmSync(pkgFolder, { recursive: true, force: true });
}

function main() {
  clean();
  build();
  patch();
}

main();
