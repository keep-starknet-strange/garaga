#!/bin/bash

# Store the original working directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"

cd "$PROJECT_ROOT/src/contracts"
echo "----------------------------------------"

get_target_dir() {
    local contract_folder_path=$1
    local metadata
    local target_dir

    # Get absolute path of the contract folder
    local abs_contract_path="$PROJECT_ROOT/src/contracts/$contract_folder_path"

    # Change to the contract directory and run scarb metadata
    metadata=$(cd "$abs_contract_path" && scarb metadata --format-version 1 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$metadata" ]]; then
        return 1
    fi

    # Extract the target_dir from the JSON output
    target_dir=$(echo "$metadata" | jq -r '.target_dir' 2>/dev/null)

    if [[ -z "$target_dir" ]] || [[ "$target_dir" == "null" ]]; then
        return 1
    fi

    # The target_dir from metadata is usually an absolute path to the workspace target
    # We need to append "/dev" to get the dev build directory
    if [[ "$target_dir" == */ ]]; then
        echo "${target_dir}dev"
    else
        echo "${target_dir}/dev"
    fi
}

# Function to build and check bytecode length
check_bytecode_length() {
    local contract_dir=$1
    local target_dir
    local abs_contract_path="$PROJECT_ROOT/src/contracts/$contract_dir"

    target_dir=$(get_target_dir "$contract_dir")
    if [[ $? -ne 0 ]] || [[ -z "$target_dir" ]]; then
        echo "Error: Could not determine target directory for $contract_dir"
        echo "----------------------------------------"
        return 1
    fi

    # echo "target_dir: $target_dir"
    cd "$abs_contract_path"
    scarb build

    # Find the compiled contract class JSON file
    # Find the files that start with the base name of the contract directory and end with "compiled_contract_class.json", with anything in between
    # ex : target/dev/groth16_example_bls12_381_Groth16VerifierBLS12_381.compiled_contract_class.json

    compiled_file=$(find "$target_dir" -type f -name "$(basename "$contract_dir")*.compiled_contract_class.json" -print -quit 2>/dev/null)
    if [[ -f "$compiled_file" ]]; then
        bytecode_length=$(jq '.bytecode | length' "$compiled_file" 2>/dev/null)
        if [[ -n "$bytecode_length" ]] && [[ "$bytecode_length" != "null" ]]; then
            # Color the output: use green for the bytecode length line
            echo -e "\e[32mBytecode length [$contract_dir] = $bytecode_length\e[0m"
        else
            echo "Error: Could not read bytecode length from $compiled_file"
        fi
        echo "----------------------------------------"
    else
        echo "Compiled contract class JSON not found in $contract_dir"
        echo "Searched in: $target_dir"
        echo "Pattern: $(basename "$contract_dir")*.compiled_contract_class.json"
        echo "----------------------------------------"
    fi
}

# List of contract directories
contracts=(
    "autogenerated/groth16_example_bn254"
    "autogenerated/groth16_example_bls12_381"
    "autogenerated/noir_ultra_keccak_honk_example"
    "autogenerated/noir_ultra_keccak_zk_honk_example"
    "autogenerated/noir_ultra_starknet_honk_example"
    "autogenerated/noir_ultra_starknet_zk_honk_example"
    "universal_ecip"
    "drand_quicknet"
    "autogenerated/risc0_verifier_bn254"
)

# Run sequentially - this is reliable and fast enough
for contract in "${contracts[@]}"; do
    check_bytecode_length "$contract"
done
